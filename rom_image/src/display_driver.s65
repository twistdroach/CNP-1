				.setcpu "65c02"
				
				.include "io.inc65"
PORTA=0										; used to shift control bits (PCR), don't modify
PORTB=1				

DISP_PORT=PA								; these define the actual locations to use
DISP_DDR=DDRA
DISP_PCR=PCR
DISP_IFR=IFR
USING_PORT=PORTA

DISP_DATA_DDR=DDRA
DISP_HANDSHAKE_DDR=DDRB
DISP_DATA=PA
DISP_HANDSHAKE=PB

.macro wait_for_avail_equal_ack
				.scope
				; LDA #$08
				; AND FLAGS
				; BNE Bit3IsSet
				; BEQ Bit3isClear

				lda #%00000010				; Check if avail is low or high
				and DISP_HANDSHAKE
				bne wait_for_ack_high		; Avail is high

wait_for_ack_low:							; avail is low
				lda #%00000100
				and DISP_HANDSHAKE
				bne wait_for_ack_low
				beq exit

wait_for_ack_high:
				lda #%00000100
				and DISP_HANDSHAKE
				beq wait_for_ack_high			

exit:
				.endscope
.endmacro

.macro invert_avail_bit
				.scope
				lda DISP_HANDSHAKE
				eor #%00000010
				sta DISP_HANDSHAKE
				.endscope
.endmacro

;Initialize for 8 bit interface
;  Data  -> PA0-7 (output) Data to be displayed
;  Avail -> PB1   (output) Flip when new data available
;  Ack   -> PB2   (input)  Set to same value as Avail when data is consumed

;  Steps to initialize
;  Set PA0-7 for output
;  Set PB1 for output
;  Set PB2 for input
;  Set a value for avail
;  Wait until Ack == Avail
.export display_initialize
.proc display_initialize
				lda #$FF					; Set PA0-7 for output
				sta DISP_DATA_DDR

				lda DISP_HANDSHAKE_DDR
				ora #%00000010				; Set PB1 for output
				and #%11111011				; Set PB2 for input
				sta	DISP_HANDSHAKE_DDR

				invert_avail_bit
				wait_for_avail_equal_ack	; Wait for display system to signal initialization is complete
				rts
.endproc

;Send value in accumulator to display
;Steps:
; Copy accumulator to DISP_DATA
; Toggle Avail
; Wait for Ack == Avail
.export display_write
.proc display_write
				pha
				sta DISP_DATA
				invert_avail_bit
				wait_for_avail_equal_ack
				pla
				rts
.endproc


.if 0
.export display_initialize
.proc display_initialize					; Destroys A, no input parameters or return values
				lda #$FF					; Set the VIA port for output
				sta DISP_DDR
											; Set the VIA port for output handshake mode
				.if (.match(USING_PORT, PORTA))
				lda #%00001011	
				.else
				lda #%10010000
				.endif
				and DISP_PCR
				sta DISP_PCR

				rts		
.endproc

.export display_write
.proc display_write							; Expects value to write in A, no return value
											; Destroys X
				tax
				
poll_for_data_taken:				
				lda DISP_IFR
				.if (.match(USING_PORT, PORTA))
				and #%00000010
				.else
				and #%00010000
				.endif
				beq poll_for_data_taken
				
				stx DISP_PORT
				rts
.endproc
.endif


.export display_initialize2
.proc display_initialize2					; Destroys A, no input parameters or return values
				lda #$FF					; Set the VIA port for output
				sta DISP_DDR
											; Set the VIA port for output handshake mode
				.if (.match(USING_PORT, PORTA))
				lda #%00001101	
				.else
				lda #%11010000
				.endif
				and DISP_PCR
				sta DISP_PCR

				rts		
.endproc



.export display_write2
.proc display_write2						; Expects value to write in A, no return value
											; Destroys X
				tax
				
poll_for_data_taken:				
				lda DISP_IFR
				.if (.match(USING_PORT, PORTA))
				clc
				lsr
				bcs CA2_is_one
				;CA2 is zero
				lsr
				bcs poll_for_data_taken ;ca2 was zero, ca1 was not				
				jmp done
CA2_is_one:
				clc
				lsr
				bcc	poll_for_data_taken		; ca2 was one, ca1 was zero	
				.else
				and #%00010000
				beq poll_for_data_taken
				.endif
				
done:				
				stx DISP_PORT
				lda #%00000010				; toggle bit to indicate write
				eor DISP_PCR
				sta DISP_PCR
				rts
.endproc