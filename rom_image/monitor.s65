					.setcpu "65c02"

					.include "macros.inc65"
					.include "bios.inc65"
					.include "hex_string_utils.inc65"
					.include "osi_bas.inc65"
					.include "disasm.inc65"
					.include "xmodem.inc65"

					.zeropage
					MON_MEM_PTR:	.res 2

					.bss
BUFFER_LENGTH		=	60
buffer:				.res BUFFER_LENGTH
tmp_hex_string:		.res 3  


					.code
					
.export monitor_entry
.proc monitor_entry
				putsln "Welcome to the Roach Monitor"
				putsln ""
loop:
				puts "RMON>"						; prompt user for a command
				lda #>buffer
				ldy #<buffer
				ldx #BUFFER_LENGTH
				jsr get_line
				putsln ""
				lda buffer							; let's interpret user's command
				beq loop							; user gave us no input, try again
				cmp #'d'							; dump - display memory
				beq do_dump
				cmp #'h'							; help - display help
				beq do_help
				cmp #'b'
				beq do_basic
				cmp #'u'
				beq do_disassembler
				cmp #'x'
				beq do_xmodem_recv
				putsln "Unknown Command"
				jmp loop
				;;the commented code just echos back
		;		lda #>buffer
		;		ldy #<buffer
		;		jsr write_bufferln

do_help:			jmp help
do_dump:			jmp dump
do_basic:			jmp COLD_START
do_disassembler:	jsr DISASM_START
					putsln ""
					jmp loop
do_xmodem_recv:		jmp XModemRcv

BYTES_TO_DUMP	= 16
dump:
				lda #>(buffer+1)
				sta R0+1
				lda #<(buffer+1)
				sta R0
				jsr scan_hex16
				
				lda RES+1
				sta MON_MEM_PTR+1
				lda RES
				sta MON_MEM_PTR
										; print location
				lda #>tmp_hex_string
				sta R0+1
				lda #<tmp_hex_string
				sta R0
				lda MON_MEM_PTR+1		; print high byte location
				jsr fmt_hex_string
				lda tmp_hex_string
				jsr write_char
				lda tmp_hex_string+1
				jsr write_char
				lda MON_MEM_PTR			; print low byte location
				jsr fmt_hex_string
				lda tmp_hex_string
				jsr write_char
				lda tmp_hex_string+1
				jsr write_char
				
				puts ": "
				
				ldy #0					; start at ptr
dump_next_byte:	
				lda #>tmp_hex_string	; print some bytes of memory
				sta R0+1				; in hex with spaces between
				lda #<tmp_hex_string
				sta R0
				lda (MON_MEM_PTR),y
				jsr fmt_hex_string
				lda tmp_hex_string
				jsr write_char
				lda tmp_hex_string+1
				jsr write_char
				lda #' '
				jsr write_char
				iny						
				cpy #BYTES_TO_DUMP		; if we've printed 8, then move on
				bne dump_next_byte
				
				puts "    !"
				;print the ascii version of the bytes
				ldy #0
dump_next_char:							; print same bytes as chars
				lda (MON_MEM_PTR),y
				cmp #$20				; print a . for anything < $20
				bcc print_dot
				cmp #$7F				; print a . for anything >= $7F
				bcs print_dot
				jsr write_char
continue_dump_next_char:
				iny
				cpy #BYTES_TO_DUMP
				bne dump_next_char
				putsln "!"
				
				putsln ""				; end the line and re-enter the monitor loop
				jmp loop
				
print_dot:		puts "."
				jmp continue_dump_next_char

help:
				putsln "Roach Monitor Help"
				putsln ""
				putsln "h - Print help"
				putsln "d - Dump memory location"
				putsln "b - Start Microsoft Basic"
				putsln "u - Start disassembler"
				putsln ""
				jmp loop
.endproc
